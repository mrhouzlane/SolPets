{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\Public\\\\Web3\\\\Github\\\\SolPets\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"C:\\\\Users\\\\Public\\\\Web3\\\\Github\\\\SolPets\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { useControllableState, useId } from \"@chakra-ui/hooks\";\nimport { ariaAttr, callAllHandlers, focus } from \"@chakra-ui/utils\";\nimport { createContext, mergeRefs } from \"@chakra-ui/react-utils\";\nimport * as React from \"react\";\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\nvar _createDescendantCont = createDescendantContext(),\n  _createDescendantCont2 = _slicedToArray(_createDescendantCont, 4),\n  PinInputDescendantsProvider = _createDescendantCont2[0],\n  usePinInputDescendantsContext = _createDescendantCont2[1],\n  usePinInputDescendants = _createDescendantCont2[2],\n  usePinInputDescendant = _createDescendantCont2[3];\n/* -------------------------------------------------------------------------------------------------\n * Create context that stores pin-input logic\n * -----------------------------------------------------------------------------------------------*/\nexport { PinInputDescendantsProvider, usePinInputDescendantsContext, usePinInputDescendants, usePinInputDescendant };\nvar _createContext = createContext({\n    name: \"PinInputContext\",\n    errorMessage: \"usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`\"\n  }),\n  _createContext2 = _slicedToArray(_createContext, 2),\n  PinInputProvider = _createContext2[0],\n  usePinInputContext = _createContext2[1];\n/* -------------------------------------------------------------------------------------------------\n * usePinInput hook\n * -----------------------------------------------------------------------------------------------*/\nexport { PinInputProvider, usePinInputContext };\nvar toArray = function toArray(value) {\n  return value == null ? void 0 : value.split(\"\");\n};\nfunction validate(value, type) {\n  var NUMERIC_REGEX = /^[0-9]+$/;\n  var ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;\n  var regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;\n  return regex.test(value);\n}\n/* -------------------------------------------------------------------------------------------------\n * usePinInput - handles the general pin input logic\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n */\n\nexport function usePinInput(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  var _props = props,\n    autoFocus = _props.autoFocus,\n    value = _props.value,\n    defaultValue = _props.defaultValue,\n    _onChange = _props.onChange,\n    onComplete = _props.onComplete,\n    _props$placeholder = _props.placeholder,\n    placeholder = _props$placeholder === void 0 ? \"â—‹\" : _props$placeholder,\n    _props$manageFocus = _props.manageFocus,\n    manageFocus = _props$manageFocus === void 0 ? true : _props$manageFocus,\n    _props$otp = _props.otp,\n    otp = _props$otp === void 0 ? false : _props$otp,\n    idProp = _props.id,\n    isDisabled = _props.isDisabled,\n    isInvalid = _props.isInvalid,\n    _props$type = _props.type,\n    type = _props$type === void 0 ? \"number\" : _props$type,\n    mask = _props.mask;\n  var uuid = useId();\n  var id = idProp != null ? idProp : \"pin-input-\" + uuid;\n  var descendants = usePinInputDescendants();\n  var _React$useState = React.useState(true),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    moveFocus = _React$useState2[0],\n    setMoveFocus = _React$useState2[1];\n  var _React$useState3 = React.useState(-1),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    focusedIndex = _React$useState4[0],\n    setFocusedIndex = _React$useState4[1];\n  var _useControllableState = useControllableState({\n      defaultValue: toArray(defaultValue) || [],\n      value: toArray(value),\n      onChange: function onChange(values) {\n        return _onChange == null ? void 0 : _onChange(values.join(\"\"));\n      }\n    }),\n    _useControllableState2 = _slicedToArray(_useControllableState, 2),\n    values = _useControllableState2[0],\n    setValues = _useControllableState2[1];\n  React.useEffect(function () {\n    if (autoFocus) {\n      var first = descendants.first();\n      if (first) focus(first.node, {\n        nextTick: true\n      });\n    } // We don't want to listen for updates to `autoFocus` since it only runs initially\n    // eslint-disable-next-line\n  }, [descendants]);\n  var focusNext = React.useCallback(function (index) {\n    if (!moveFocus || !manageFocus) return;\n    var next = descendants.next(index, false);\n    if (next) focus(next.node, {\n      nextTick: true\n    });\n  }, [descendants, moveFocus, manageFocus]);\n  var setValue = React.useCallback(function (value, index) {\n    var nextValues = _toConsumableArray(values);\n    nextValues[index] = value;\n    setValues(nextValues);\n    var isComplete = value !== \"\" && nextValues.length === descendants.count() && nextValues.every(function (inputValue) {\n      return inputValue != null && inputValue !== \"\";\n    });\n    if (isComplete) {\n      onComplete == null ? void 0 : onComplete(nextValues.join(\"\"));\n    } else {\n      focusNext(index);\n    }\n  }, [values, setValues, focusNext, onComplete, descendants]);\n  var clear = React.useCallback(function () {\n    var values = Array(descendants.count()).fill(\"\");\n    setValues(values);\n    var first = descendants.first();\n    if (first) focus(first.node);\n  }, [descendants, setValues]);\n  var getNextValue = React.useCallback(function (value, eventValue) {\n    var nextValue = eventValue;\n    if ((value == null ? void 0 : value.length) > 0) {\n      if (value[0] === eventValue.charAt(0)) {\n        nextValue = eventValue.charAt(1);\n      } else if (value[0] === eventValue.charAt(1)) {\n        nextValue = eventValue.charAt(0);\n      }\n    }\n    return nextValue;\n  }, []);\n  var getInputProps = React.useCallback(function (props) {\n    var index = props.index,\n      rest = _objectWithoutPropertiesLoose(props, [\"index\"]);\n\n    /**\n     * Improved from: https://github.com/uber/baseweb/blob/master/src/pin-code/pin-code.js\n     */\n\n    var onChange = function onChange(event) {\n      var eventValue = event.target.value;\n      var currentValue = values[index];\n      var nextValue = getNextValue(currentValue, eventValue); // if the value was removed using backspace\n\n      if (nextValue === \"\") {\n        setValue(\"\", index);\n        return;\n      } // in the case of an autocomplete or copy and paste\n\n      if (eventValue.length > 2) {\n        // see if we can use the string to fill out our values\n        if (validate(eventValue, type)) {\n          // Ensure the value matches the number of inputs\n          var _nextValue = eventValue.split(\"\").filter(function (_, index) {\n            return index < descendants.count();\n          });\n          setValues(_nextValue); // if pasting fills the entire input fields, trigger `onComplete`\n\n          if (_nextValue.length === descendants.count()) {\n            onComplete == null ? void 0 : onComplete(_nextValue.join(\"\"));\n          }\n        }\n      } else {\n        // only set if the new value is a number\n        if (validate(nextValue, type)) {\n          setValue(nextValue, index);\n        }\n        setMoveFocus(true);\n      }\n    };\n    var onKeyDown = function onKeyDown(event) {\n      if (event.key === \"Backspace\" && manageFocus) {\n        if (event.target.value === \"\") {\n          var prevInput = descendants.prev(index, false);\n          if (prevInput) {\n            setValue(\"\", index - 1);\n            focus(prevInput.node);\n            setMoveFocus(true);\n          }\n        } else {\n          setMoveFocus(false);\n        }\n      }\n    };\n    var onFocus = function onFocus() {\n      setFocusedIndex(index);\n    };\n    var onBlur = function onBlur() {\n      setFocusedIndex(-1);\n    };\n    var hasFocus = focusedIndex === index;\n    var inputType = type === \"number\" ? \"tel\" : \"text\";\n    return _extends({\n      \"aria-label\": \"Please enter your pin code\",\n      inputMode: type === \"number\" ? \"numeric\" : \"text\",\n      type: mask ? \"password\" : inputType\n    }, rest, {\n      id: id + \"-\" + index,\n      disabled: isDisabled,\n      \"aria-invalid\": ariaAttr(isInvalid),\n      onChange: callAllHandlers(rest.onChange, onChange),\n      onKeyDown: callAllHandlers(rest.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(rest.onFocus, onFocus),\n      onBlur: callAllHandlers(rest.onBlur, onBlur),\n      value: values[index] || \"\",\n      autoComplete: otp ? \"one-time-code\" : \"off\",\n      placeholder: hasFocus ? \"\" : placeholder\n    });\n  }, [descendants, focusedIndex, getNextValue, id, isDisabled, mask, isInvalid, manageFocus, onComplete, otp, placeholder, setValue, setValues, type, values]);\n  return {\n    // prop getter\n    getInputProps: getInputProps,\n    // state\n    id: id,\n    descendants: descendants,\n    values: values,\n    // actions\n    setValue: setValue,\n    setValues: setValues,\n    clear: clear\n  };\n}\n\n/**\n * @internal\n */\nexport function usePinInputField(props, ref) {\n  if (props === void 0) {\n    props = {};\n  }\n  if (ref === void 0) {\n    ref = null;\n  }\n  var _usePinInputContext = usePinInputContext(),\n    getInputProps = _usePinInputContext.getInputProps;\n  var _usePinInputDescendan = usePinInputDescendant(),\n    index = _usePinInputDescendan.index,\n    register = _usePinInputDescendan.register;\n  return getInputProps(_extends({}, props, {\n    ref: mergeRefs(register, ref),\n    index: index\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}
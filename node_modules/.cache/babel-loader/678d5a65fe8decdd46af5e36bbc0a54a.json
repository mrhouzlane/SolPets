{"ast":null,"code":"module.exports = /******/function (modules) {\n  // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/if (installedModules[moduleId]) {\n      /******/return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/i: moduleId,\n      /******/l: false,\n      /******/exports: {}\n      /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.l = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // define getter function for harmony exports\n  /******/\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/if (!__webpack_require__.o(exports, name)) {\n      /******/Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n  };\n  /******/\n  /******/ // define __esModule on exports\n  /******/\n  __webpack_require__.r = function (exports) {\n    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n  /******/ // create a fake namespace object\n  /******/ // mode & 1: value is a module id, require it\n  /******/ // mode & 2: merge all properties of value into the ns\n  /******/ // mode & 4: return value when already ns object\n  /******/ // mode & 8|1: behave like require\n  /******/\n  __webpack_require__.t = function (value, mode) {\n    /******/if (mode & 1) value = __webpack_require__(value);\n    /******/\n    if (mode & 8) return value;\n    /******/\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n    var ns = Object.create(null);\n    /******/\n    __webpack_require__.r(ns);\n    /******/\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n      return value[key];\n    }.bind(null, key));\n    /******/\n    return ns;\n    /******/\n  };\n  /******/\n  /******/ // getDefaultExport function for compatibility with non-harmony modules\n  /******/\n  __webpack_require__.n = function (module) {\n    /******/var getter = module && module.__esModule ? /******/function getDefault() {\n      return module['default'];\n    } : /******/function getModuleExports() {\n      return module;\n    };\n    /******/\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n    return getter;\n    /******/\n  };\n  /******/\n  /******/ // Object.prototype.hasOwnProperty.call\n  /******/\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"\";\n  /******/\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(__webpack_require__.s = 20);\n  /******/\n}\n/************************************************************************/\n/******/([/* 0 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\n  /***/\n}, /* 1 */\n/***/function (module, exports) {\n  module.exports = require(\"randombytes\");\n\n  /***/\n}, /* 2 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/classCallCheck\");\n\n  /***/\n}, /* 3 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/createClass\");\n\n  /***/\n}, /* 4 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/assertThisInitialized\");\n\n  /***/\n}, /* 5 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/get\");\n\n  /***/\n}, /* 6 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/inherits\");\n\n  /***/\n}, /* 7 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\n  /***/\n}, /* 8 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\n  /***/\n}, /* 9 */\n/***/function (module, exports) {\n  module.exports = require(\"@babel/runtime/helpers/defineProperty\");\n\n  /***/\n}, /* 10 */\n/***/function (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  var punycode = __webpack_require__(13);\n  var util = __webpack_require__(16);\n  exports.parse = urlParse;\n  exports.resolve = urlResolve;\n  exports.resolveObject = urlResolveObject;\n  exports.format = urlFormat;\n  exports.Url = Url;\n  function Url() {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.host = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.query = null;\n    this.pathname = null;\n    this.path = null;\n    this.href = null;\n  }\n\n  // Reference: RFC 3986, RFC 1808, RFC 2396\n\n  // define these here so at least they only have to be\n  // compiled once on the first module load.\n  var protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(17);\n  function urlParse(url, parseQueryString, slashesDenoteHost) {\n    if (url && util.isObject(url) && url instanceof Url) return url;\n    var u = new Url();\n    u.parse(url, parseQueryString, slashesDenoteHost);\n    return u;\n  }\n  Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n    if (!util.isString(url)) {\n      throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n    }\n\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    var queryIndex = url.indexOf('?'),\n      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n    uSplit[0] = uSplit[0].replace(slashRegex, '/');\n    url = uSplit.join(splitter);\n    var rest = url;\n\n    // trim before proceeding.\n    // This is to support parse stuff like \"  http://foo.com  \\n\"\n    rest = rest.trim();\n    if (!slashesDenoteHost && url.split('#').length === 1) {\n      // Try fast path regexp\n      var simplePath = simplePathPattern.exec(rest);\n      if (simplePath) {\n        this.path = rest;\n        this.href = rest;\n        this.pathname = simplePath[1];\n        if (simplePath[2]) {\n          this.search = simplePath[2];\n          if (parseQueryString) {\n            this.query = querystring.parse(this.search.substr(1));\n          } else {\n            this.query = this.search.substr(1);\n          }\n        } else if (parseQueryString) {\n          this.search = '';\n          this.query = {};\n        }\n        return this;\n      }\n    }\n    var proto = protocolPattern.exec(rest);\n    if (proto) {\n      proto = proto[0];\n      var lowerProto = proto.toLowerCase();\n      this.protocol = lowerProto;\n      rest = rest.substr(proto.length);\n    }\n\n    // figure out if it's got a host\n    // user@server is *always* interpreted as a hostname, and url\n    // resolution will treat //foo/bar as host=foo,path=bar because that's\n    // how the browser resolves relative URLs.\n    if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n      var slashes = rest.substr(0, 2) === '//';\n      if (slashes && !(proto && hostlessProtocol[proto])) {\n        rest = rest.substr(2);\n        this.slashes = true;\n      }\n    }\n    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n      // there's a hostname.\n      // the first instance of /, ?, ;, or # ends the host.\n      //\n      // If there is an @ in the hostname, then non-host chars *are* allowed\n      // to the left of the last @ sign, unless some host-ending character\n      // comes *before* the @-sign.\n      // URLs are obnoxious.\n      //\n      // ex:\n      // http://a@b@c/ => user:a@b host:c\n      // http://a@b?@c => user:a host:c path:/?@c\n\n      // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n      // Review our test case against browsers more comprehensively.\n\n      // find the first instance of any hostEndingChars\n      var hostEnd = -1;\n      for (var i = 0; i < hostEndingChars.length; i++) {\n        var hec = rest.indexOf(hostEndingChars[i]);\n        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n      }\n\n      // at this point, either we have an explicit point where the\n      // auth portion cannot go past, or the last @ char is the decider.\n      var auth, atSign;\n      if (hostEnd === -1) {\n        // atSign can be anywhere.\n        atSign = rest.lastIndexOf('@');\n      } else {\n        // atSign must be in auth portion.\n        // http://a@b/c@d => host:b auth:a path:/c@d\n        atSign = rest.lastIndexOf('@', hostEnd);\n      }\n\n      // Now we have a portion which is definitely the auth.\n      // Pull that off.\n      if (atSign !== -1) {\n        auth = rest.slice(0, atSign);\n        rest = rest.slice(atSign + 1);\n        this.auth = decodeURIComponent(auth);\n      }\n\n      // the host is the remaining to the left of the first non-host char\n      hostEnd = -1;\n      for (var i = 0; i < nonHostChars.length; i++) {\n        var hec = rest.indexOf(nonHostChars[i]);\n        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n      }\n      // if we still have not hit it, then the entire thing is a host.\n      if (hostEnd === -1) hostEnd = rest.length;\n      this.host = rest.slice(0, hostEnd);\n      rest = rest.slice(hostEnd);\n\n      // pull out port.\n      this.parseHost();\n\n      // we've indicated that there is a hostname,\n      // so even if it's empty, it has to be present.\n      this.hostname = this.hostname || '';\n\n      // if hostname begins with [ and ends with ]\n      // assume that it's an IPv6 address.\n      var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n      // validate a little.\n      if (!ipv6Hostname) {\n        var hostparts = this.hostname.split(/\\./);\n        for (var i = 0, l = hostparts.length; i < l; i++) {\n          var part = hostparts[i];\n          if (!part) continue;\n          if (!part.match(hostnamePartPattern)) {\n            var newpart = '';\n            for (var j = 0, k = part.length; j < k; j++) {\n              if (part.charCodeAt(j) > 127) {\n                // we replace non-ASCII char with a temporary placeholder\n                // we need this to make sure size of hostname is not\n                // broken by replacing non-ASCII by nothing\n                newpart += 'x';\n              } else {\n                newpart += part[j];\n              }\n            }\n            // we test again with ASCII char only\n            if (!newpart.match(hostnamePartPattern)) {\n              var validParts = hostparts.slice(0, i);\n              var notHost = hostparts.slice(i + 1);\n              var bit = part.match(hostnamePartStart);\n              if (bit) {\n                validParts.push(bit[1]);\n                notHost.unshift(bit[2]);\n              }\n              if (notHost.length) {\n                rest = '/' + notHost.join('.') + rest;\n              }\n              this.hostname = validParts.join('.');\n              break;\n            }\n          }\n        }\n      }\n      if (this.hostname.length > hostnameMaxLen) {\n        this.hostname = '';\n      } else {\n        // hostnames are always lower case.\n        this.hostname = this.hostname.toLowerCase();\n      }\n      if (!ipv6Hostname) {\n        // IDNA Support: Returns a punycoded representation of \"domain\".\n        // It only converts parts of the domain name that\n        // have non-ASCII characters, i.e. it doesn't matter if\n        // you call it with a domain that already is ASCII-only.\n        this.hostname = punycode.toASCII(this.hostname);\n      }\n      var p = this.port ? ':' + this.port : '';\n      var h = this.hostname || '';\n      this.host = h + p;\n      this.href += this.host;\n\n      // strip [ and ] from the hostname\n      // the host field still retains them, though\n      if (ipv6Hostname) {\n        this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n        if (rest[0] !== '/') {\n          rest = '/' + rest;\n        }\n      }\n    }\n\n    // now rest is set to the post-host stuff.\n    // chop off any delim chars.\n    if (!unsafeProtocol[lowerProto]) {\n      // First, make 100% sure that any \"autoEscape\" chars get\n      // escaped, even if encodeURIComponent doesn't think they\n      // need to be.\n      for (var i = 0, l = autoEscape.length; i < l; i++) {\n        var ae = autoEscape[i];\n        if (rest.indexOf(ae) === -1) continue;\n        var esc = encodeURIComponent(ae);\n        if (esc === ae) {\n          esc = escape(ae);\n        }\n        rest = rest.split(ae).join(esc);\n      }\n    }\n\n    // chop off from the tail first.\n    var hash = rest.indexOf('#');\n    if (hash !== -1) {\n      // got a fragment string.\n      this.hash = rest.substr(hash);\n      rest = rest.slice(0, hash);\n    }\n    var qm = rest.indexOf('?');\n    if (qm !== -1) {\n      this.search = rest.substr(qm);\n      this.query = rest.substr(qm + 1);\n      if (parseQueryString) {\n        this.query = querystring.parse(this.query);\n      }\n      rest = rest.slice(0, qm);\n    } else if (parseQueryString) {\n      // no query string, but parseQueryString still requested\n      this.search = '';\n      this.query = {};\n    }\n    if (rest) this.pathname = rest;\n    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n      this.pathname = '/';\n    }\n\n    //to support http.request\n    if (this.pathname || this.search) {\n      var p = this.pathname || '';\n      var s = this.search || '';\n      this.path = p + s;\n    }\n\n    // finally, reconstruct the href based on what has been validated.\n    this.href = this.format();\n    return this;\n  };\n\n  // format a parsed object into a url string\n  function urlFormat(obj) {\n    // ensure it's an object, and not a string url.\n    // If it's an obj, this is a no-op.\n    // this way, you can call url_format() on strings\n    // to clean up potentially wonky urls.\n    if (util.isString(obj)) obj = urlParse(obj);\n    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n    return obj.format();\n  }\n  Url.prototype.format = function () {\n    var auth = this.auth || '';\n    if (auth) {\n      auth = encodeURIComponent(auth);\n      auth = auth.replace(/%3A/i, ':');\n      auth += '@';\n    }\n    var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n    if (this.host) {\n      host = auth + this.host;\n    } else if (this.hostname) {\n      host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n      if (this.port) {\n        host += ':' + this.port;\n      }\n    }\n    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n      query = querystring.stringify(this.query);\n    }\n    var search = this.search || query && '?' + query || '';\n    if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n    // unless they had them to begin with.\n    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n      host = '//' + (host || '');\n      if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n      host = '';\n    }\n    if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n    if (search && search.charAt(0) !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, function (match) {\n      return encodeURIComponent(match);\n    });\n    search = search.replace('#', '%23');\n    return protocol + host + pathname + search + hash;\n  };\n  function urlResolve(source, relative) {\n    return urlParse(source, false, true).resolve(relative);\n  }\n  Url.prototype.resolve = function (relative) {\n    return this.resolveObject(urlParse(relative, false, true)).format();\n  };\n  function urlResolveObject(source, relative) {\n    if (!source) return relative;\n    return urlParse(source, false, true).resolveObject(relative);\n  }\n  Url.prototype.resolveObject = function (relative) {\n    if (util.isString(relative)) {\n      var rel = new Url();\n      rel.parse(relative, false, true);\n      relative = rel;\n    }\n    var result = new Url();\n    var tkeys = Object.keys(this);\n    for (var tk = 0; tk < tkeys.length; tk++) {\n      var tkey = tkeys[tk];\n      result[tkey] = this[tkey];\n    }\n\n    // hash is always overridden, no matter what.\n    // even href=\"\" will remove it.\n    result.hash = relative.hash;\n\n    // if the relative url is empty, then there's nothing left to do here.\n    if (relative.href === '') {\n      result.href = result.format();\n      return result;\n    }\n\n    // hrefs like //foo/bar always cut to the protocol.\n    if (relative.slashes && !relative.protocol) {\n      // take everything except the protocol from relative\n      var rkeys = Object.keys(relative);\n      for (var rk = 0; rk < rkeys.length; rk++) {\n        var rkey = rkeys[rk];\n        if (rkey !== 'protocol') result[rkey] = relative[rkey];\n      }\n\n      //urlParse appends trailing / to urls like http://www.example.com\n      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n        result.path = result.pathname = '/';\n      }\n      result.href = result.format();\n      return result;\n    }\n    if (relative.protocol && relative.protocol !== result.protocol) {\n      // if it's a known url protocol, then changing\n      // the protocol does weird things\n      // first, if it's not file:, then we MUST have a host,\n      // and if there was a path\n      // to begin with, then we MUST have a path.\n      // if it is file:, then the host is dropped,\n      // because that's known to be hostless.\n      // anything else is assumed to be absolute.\n      if (!slashedProtocol[relative.protocol]) {\n        var keys = Object.keys(relative);\n        for (var v = 0; v < keys.length; v++) {\n          var k = keys[v];\n          result[k] = relative[k];\n        }\n        result.href = result.format();\n        return result;\n      }\n      result.protocol = relative.protocol;\n      if (!relative.host && !hostlessProtocol[relative.protocol]) {\n        var relPath = (relative.pathname || '').split('/');\n        while (relPath.length && !(relative.host = relPath.shift()));\n        if (!relative.host) relative.host = '';\n        if (!relative.hostname) relative.hostname = '';\n        if (relPath[0] !== '') relPath.unshift('');\n        if (relPath.length < 2) relPath.unshift('');\n        result.pathname = relPath.join('/');\n      } else {\n        result.pathname = relative.pathname;\n      }\n      result.search = relative.search;\n      result.query = relative.query;\n      result.host = relative.host || '';\n      result.auth = relative.auth;\n      result.hostname = relative.hostname || relative.host;\n      result.port = relative.port;\n      // to support http.request\n      if (result.pathname || result.search) {\n        var p = result.pathname || '';\n        var s = result.search || '';\n        result.path = p + s;\n      }\n      result.slashes = result.slashes || relative.slashes;\n      result.href = result.format();\n      return result;\n    }\n    var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n    // if the url is a non-slashed url, then relative\n    // links like ../.. should be able\n    // to crawl up to the hostname, as well.  This is strange.\n    // result.protocol has already been set by now.\n    // Later on, put the first path part into the host field.\n    if (psychotic) {\n      result.hostname = '';\n      result.port = null;\n      if (result.host) {\n        if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n      }\n      result.host = '';\n      if (relative.protocol) {\n        relative.hostname = null;\n        relative.port = null;\n        if (relative.host) {\n          if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n        }\n        relative.host = null;\n      }\n      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n    }\n    if (isRelAbs) {\n      // it's absolute.\n      result.host = relative.host || relative.host === '' ? relative.host : result.host;\n      result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n      result.search = relative.search;\n      result.query = relative.query;\n      srcPath = relPath;\n      // fall through to the dot-handling below.\n    } else if (relPath.length) {\n      // it's relative\n      // throw away the existing file, and take the new path instead.\n      if (!srcPath) srcPath = [];\n      srcPath.pop();\n      srcPath = srcPath.concat(relPath);\n      result.search = relative.search;\n      result.query = relative.query;\n    } else if (!util.isNullOrUndefined(relative.search)) {\n      // just pull out the search.\n      // like href='?foo'.\n      // Put this after the other two cases because it simplifies the booleans\n      if (psychotic) {\n        result.hostname = result.host = srcPath.shift();\n        //occationaly the auth can get stuck only in host\n        //this especially happens in cases like\n        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n        if (authInHost) {\n          result.auth = authInHost.shift();\n          result.host = result.hostname = authInHost.shift();\n        }\n      }\n      result.search = relative.search;\n      result.query = relative.query;\n      //to support http.request\n      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n      }\n      result.href = result.format();\n      return result;\n    }\n    if (!srcPath.length) {\n      // no path at all.  easy.\n      // we've already handled the other stuff above.\n      result.pathname = null;\n      //to support http.request\n      if (result.search) {\n        result.path = '/' + result.search;\n      } else {\n        result.path = null;\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    // if a url ENDs in . or .., then it must get a trailing slash.\n    // however, if it ends in anything else non-slashy,\n    // then it must NOT get a trailing slash.\n    var last = srcPath.slice(-1)[0];\n    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n    // strip single dots, resolve double dots to parent dir\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n    for (var i = srcPath.length; i >= 0; i--) {\n      last = srcPath[i];\n      if (last === '.') {\n        srcPath.splice(i, 1);\n      } else if (last === '..') {\n        srcPath.splice(i, 1);\n        up++;\n      } else if (up) {\n        srcPath.splice(i, 1);\n        up--;\n      }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (!mustEndAbs && !removeAllDots) {\n      for (; up--; up) {\n        srcPath.unshift('..');\n      }\n    }\n    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n      srcPath.unshift('');\n    }\n    if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n      srcPath.push('');\n    }\n    var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\n\n    // put the host back\n    if (psychotic) {\n      result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    mustEndAbs = mustEndAbs || result.host && srcPath.length;\n    if (mustEndAbs && !isAbsolute) {\n      srcPath.unshift('');\n    }\n    if (!srcPath.length) {\n      result.pathname = null;\n      result.path = null;\n    } else {\n      result.pathname = srcPath.join('/');\n    }\n\n    //to support request.http\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.auth = relative.auth || result.auth;\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  };\n  Url.prototype.parseHost = function () {\n    var host = this.host;\n    var port = portPattern.exec(host);\n    if (port) {\n      port = port[0];\n      if (port !== ':') {\n        this.port = port.substr(1);\n      }\n      host = host.substr(0, host.length - port.length);\n    }\n    if (host) this.hostname = host;\n  };\n\n  /***/\n}, /* 11 */\n/***/function (module, exports) {\n  module.exports = require(\"base64url\");\n\n  /***/\n}, /* 12 */\n/***/function (module, exports) {\n  module.exports = require(\"keccak\");\n\n  /***/\n}, /* 13 */\n/***/function (module, exports, __webpack_require__) {\n  /* WEBPACK VAR INJECTION */(function (module, global) {\n    var __WEBPACK_AMD_DEFINE_RESULT__; /*! https://mths.be/punycode v1.4.1 by @mathias */\n    ;\n    (function (root) {\n      /** Detect free variables */\n      var freeExports = true && exports && !exports.nodeType && exports;\n      var freeModule = true && module && !module.nodeType && module;\n      var freeGlobal = typeof global == 'object' && global;\n      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n        root = freeGlobal;\n      }\n\n      /**\n       * The `punycode` object.\n       * @name punycode\n       * @type Object\n       */\n      var punycode,\n        /** Highest positive signed 32-bit float value */\n        maxInt = 2147483647,\n        // aka. 0x7FFFFFFF or 2^31-1\n\n        /** Bootstring parameters */\n        base = 36,\n        tMin = 1,\n        tMax = 26,\n        skew = 38,\n        damp = 700,\n        initialBias = 72,\n        initialN = 128,\n        // 0x80\n        delimiter = '-',\n        // '\\x2D'\n\n        /** Regular expressions */\n        regexPunycode = /^xn--/,\n        regexNonASCII = /[^\\x20-\\x7E]/,\n        // unprintable ASCII chars + non-ASCII chars\n        regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n        // RFC 3490 separators\n\n        /** Error messages */\n        errors = {\n          'overflow': 'Overflow: input needs wider integers to process',\n          'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n          'invalid-input': 'Invalid input'\n        },\n        /** Convenience shortcuts */\n        baseMinusTMin = base - tMin,\n        floor = Math.floor,\n        stringFromCharCode = String.fromCharCode,\n        /** Temporary variable */\n        key;\n\n      /*--------------------------------------------------------------------------*/\n\n      /**\n       * A generic error utility function.\n       * @private\n       * @param {String} type The error type.\n       * @returns {Error} Throws a `RangeError` with the applicable error message.\n       */\n      function error(type) {\n        throw new RangeError(errors[type]);\n      }\n\n      /**\n       * A generic `Array#map` utility function.\n       * @private\n       * @param {Array} array The array to iterate over.\n       * @param {Function} callback The function that gets called for every array\n       * item.\n       * @returns {Array} A new array of values returned by the callback function.\n       */\n      function map(array, fn) {\n        var length = array.length;\n        var result = [];\n        while (length--) {\n          result[length] = fn(array[length]);\n        }\n        return result;\n      }\n\n      /**\n       * A simple `Array#map`-like wrapper to work with domain name strings or email\n       * addresses.\n       * @private\n       * @param {String} domain The domain name or email address.\n       * @param {Function} callback The function that gets called for every\n       * character.\n       * @returns {Array} A new string of characters returned by the callback\n       * function.\n       */\n      function mapDomain(string, fn) {\n        var parts = string.split('@');\n        var result = '';\n        if (parts.length > 1) {\n          // In email addresses, only the domain name should be punycoded. Leave\n          // the local part (i.e. everything up to `@`) intact.\n          result = parts[0] + '@';\n          string = parts[1];\n        }\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, '\\x2E');\n        var labels = string.split('.');\n        var encoded = map(labels, fn).join('.');\n        return result + encoded;\n      }\n\n      /**\n       * Creates an array containing the numeric code points of each Unicode\n       * character in the string. While JavaScript uses UCS-2 internally,\n       * this function will convert a pair of surrogate halves (each of which\n       * UCS-2 exposes as separate characters) into a single code point,\n       * matching UTF-16.\n       * @see `punycode.ucs2.encode`\n       * @see <https://mathiasbynens.be/notes/javascript-encoding>\n       * @memberOf punycode.ucs2\n       * @name decode\n       * @param {String} string The Unicode input string (UCS-2).\n       * @returns {Array} The new array of code points.\n       */\n      function ucs2decode(string) {\n        var output = [],\n          counter = 0,\n          length = string.length,\n          value,\n          extra;\n        while (counter < length) {\n          value = string.charCodeAt(counter++);\n          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n            // high surrogate, and there is a next character\n            extra = string.charCodeAt(counter++);\n            if ((extra & 0xFC00) == 0xDC00) {\n              // low surrogate\n              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n            } else {\n              // unmatched surrogate; only append this code unit, in case the next\n              // code unit is the high surrogate of a surrogate pair\n              output.push(value);\n              counter--;\n            }\n          } else {\n            output.push(value);\n          }\n        }\n        return output;\n      }\n\n      /**\n       * Creates a string based on an array of numeric code points.\n       * @see `punycode.ucs2.decode`\n       * @memberOf punycode.ucs2\n       * @name encode\n       * @param {Array} codePoints The array of numeric code points.\n       * @returns {String} The new Unicode string (UCS-2).\n       */\n      function ucs2encode(array) {\n        return map(array, function (value) {\n          var output = '';\n          if (value > 0xFFFF) {\n            value -= 0x10000;\n            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n            value = 0xDC00 | value & 0x3FF;\n          }\n          output += stringFromCharCode(value);\n          return output;\n        }).join('');\n      }\n\n      /**\n       * Converts a basic code point into a digit/integer.\n       * @see `digitToBasic()`\n       * @private\n       * @param {Number} codePoint The basic numeric code point value.\n       * @returns {Number} The numeric value of a basic code point (for use in\n       * representing integers) in the range `0` to `base - 1`, or `base` if\n       * the code point does not represent a value.\n       */\n      function basicToDigit(codePoint) {\n        if (codePoint - 48 < 10) {\n          return codePoint - 22;\n        }\n        if (codePoint - 65 < 26) {\n          return codePoint - 65;\n        }\n        if (codePoint - 97 < 26) {\n          return codePoint - 97;\n        }\n        return base;\n      }\n\n      /**\n       * Converts a digit/integer into a basic code point.\n       * @see `basicToDigit()`\n       * @private\n       * @param {Number} digit The numeric value of a basic code point.\n       * @returns {Number} The basic code point whose value (when used for\n       * representing integers) is `digit`, which needs to be in the range\n       * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n       * used; else, the lowercase form is used. The behavior is undefined\n       * if `flag` is non-zero and `digit` has no uppercase form.\n       */\n      function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n      }\n\n      /**\n       * Bias adaptation function as per section 3.4 of RFC 3492.\n       * https://tools.ietf.org/html/rfc3492#section-3.4\n       * @private\n       */\n      function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for /* no initialization */\n        (; delta > baseMinusTMin * tMax >> 1; k += base) {\n          delta = floor(delta / baseMinusTMin);\n        }\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n      }\n\n      /**\n       * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n       * symbols.\n       * @memberOf punycode\n       * @param {String} input The Punycode string of ASCII-only symbols.\n       * @returns {String} The resulting string of Unicode symbols.\n       */\n      function decode(input) {\n        // Don't use UCS-2\n        var output = [],\n          inputLength = input.length,\n          out,\n          i = 0,\n          n = initialN,\n          bias = initialBias,\n          basic,\n          j,\n          index,\n          oldi,\n          w,\n          k,\n          digit,\n          t,\n          /** Cached calculation results */\n          baseMinusT;\n\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n\n        basic = input.lastIndexOf(delimiter);\n        if (basic < 0) {\n          basic = 0;\n        }\n        for (j = 0; j < basic; ++j) {\n          // if it's not a basic code point\n          if (input.charCodeAt(j) >= 0x80) {\n            error('not-basic');\n          }\n          output.push(input.charCodeAt(j));\n        }\n\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n\n        for /* no final expression */\n        (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n          // `index` is the index of the next character to be consumed.\n          // Decode a generalized variable-length integer into `delta`,\n          // which gets added to `i`. The overflow checking is easier\n          // if we increase `i` as we go, then subtract off its starting\n          // value at the end to obtain `delta`.\n          for /* no condition */\n          (oldi = i, w = 1, k = base;; k += base) {\n            if (index >= inputLength) {\n              error('invalid-input');\n            }\n            digit = basicToDigit(input.charCodeAt(index++));\n            if (digit >= base || digit > floor((maxInt - i) / w)) {\n              error('overflow');\n            }\n            i += digit * w;\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (digit < t) {\n              break;\n            }\n            baseMinusT = base - t;\n            if (w > floor(maxInt / baseMinusT)) {\n              error('overflow');\n            }\n            w *= baseMinusT;\n          }\n          out = output.length + 1;\n          bias = adapt(i - oldi, out, oldi == 0);\n\n          // `i` was supposed to wrap around from `out` to `0`,\n          // incrementing `n` each time, so we'll fix that now:\n          if (floor(i / out) > maxInt - n) {\n            error('overflow');\n          }\n          n += floor(i / out);\n          i %= out;\n\n          // Insert `n` at position `i` of the output\n          output.splice(i++, 0, n);\n        }\n        return ucs2encode(output);\n      }\n\n      /**\n       * Converts a string of Unicode symbols (e.g. a domain name label) to a\n       * Punycode string of ASCII-only symbols.\n       * @memberOf punycode\n       * @param {String} input The string of Unicode symbols.\n       * @returns {String} The resulting Punycode string of ASCII-only symbols.\n       */\n      function encode(input) {\n        var n,\n          delta,\n          handledCPCount,\n          basicLength,\n          bias,\n          j,\n          m,\n          q,\n          k,\n          t,\n          currentValue,\n          output = [],\n          /** `inputLength` will hold the number of code points in `input`. */\n          inputLength,\n          /** Cached calculation results */\n          handledCPCountPlusOne,\n          baseMinusT,\n          qMinusT;\n\n        // Convert the input in UCS-2 to Unicode\n        input = ucs2decode(input);\n\n        // Cache the length\n        inputLength = input.length;\n\n        // Initialize the state\n        n = initialN;\n        delta = 0;\n        bias = initialBias;\n\n        // Handle the basic code points\n        for (j = 0; j < inputLength; ++j) {\n          currentValue = input[j];\n          if (currentValue < 0x80) {\n            output.push(stringFromCharCode(currentValue));\n          }\n        }\n        handledCPCount = basicLength = output.length;\n\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n\n        // Finish the basic string - if it is not empty - with a delimiter\n        if (basicLength) {\n          output.push(delimiter);\n        }\n\n        // Main encoding loop:\n        while (handledCPCount < inputLength) {\n          // All non-basic code points < n have been handled already. Find the next\n          // larger one:\n          for (m = maxInt, j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue >= n && currentValue < m) {\n              m = currentValue;\n            }\n          }\n\n          // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n          // but guard against overflow\n          handledCPCountPlusOne = handledCPCount + 1;\n          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n            error('overflow');\n          }\n          delta += (m - n) * handledCPCountPlusOne;\n          n = m;\n          for (j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue < n && ++delta > maxInt) {\n              error('overflow');\n            }\n            if (currentValue == n) {\n              // Represent delta as a generalized variable-length integer\n              for /* no condition */\n              (q = delta, k = base;; k += base) {\n                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (q < t) {\n                  break;\n                }\n                qMinusT = q - t;\n                baseMinusT = base - t;\n                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                q = floor(qMinusT / baseMinusT);\n              }\n              output.push(stringFromCharCode(digitToBasic(q, 0)));\n              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n              delta = 0;\n              ++handledCPCount;\n            }\n          }\n          ++delta;\n          ++n;\n        }\n        return output.join('');\n      }\n\n      /**\n       * Converts a Punycode string representing a domain name or an email address\n       * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n       * it doesn't matter if you call it on a string that has already been\n       * converted to Unicode.\n       * @memberOf punycode\n       * @param {String} input The Punycoded domain name or email address to\n       * convert to Unicode.\n       * @returns {String} The Unicode representation of the given Punycode\n       * string.\n       */\n      function toUnicode(input) {\n        return mapDomain(input, function (string) {\n          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n        });\n      }\n\n      /**\n       * Converts a Unicode string representing a domain name or an email address to\n       * Punycode. Only the non-ASCII parts of the domain name will be converted,\n       * i.e. it doesn't matter if you call it with a domain that's already in\n       * ASCII.\n       * @memberOf punycode\n       * @param {String} input The domain name or email address to convert, as a\n       * Unicode string.\n       * @returns {String} The Punycode representation of the given domain name or\n       * email address.\n       */\n      function toASCII(input) {\n        return mapDomain(input, function (string) {\n          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n        });\n      }\n\n      /*--------------------------------------------------------------------------*/\n\n      /** Define the public API */\n      punycode = {\n        /**\n         * A string representing the current Punycode.js version number.\n         * @memberOf punycode\n         * @type String\n         */\n        'version': '1.4.1',\n        /**\n         * An object of methods to convert from JavaScript's internal character\n         * representation (UCS-2) to Unicode code points, and back.\n         * @see <https://mathiasbynens.be/notes/javascript-encoding>\n         * @memberOf punycode\n         * @type Object\n         */\n        'ucs2': {\n          'decode': ucs2decode,\n          'encode': ucs2encode\n        },\n        'decode': decode,\n        'encode': encode,\n        'toASCII': toASCII,\n        'toUnicode': toUnicode\n      };\n\n      /** Expose `punycode` */\n      // Some AMD build optimizers, like r.js, check for specific condition patterns\n      // like the following:\n      if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n          return punycode;\n        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      } else {}\n    })(this);\n\n    /* WEBPACK VAR INJECTION */\n  }).call(this, __webpack_require__(14)(module), __webpack_require__(15));\n\n  /***/\n}, /* 14 */\n/***/function (module, exports) {\n  module.exports = function (module) {\n    if (!module.webpackPolyfill) {\n      module.deprecate = function () {};\n      module.paths = [];\n      // module.parent = undefined by default\n      if (!module.children) module.children = [];\n      Object.defineProperty(module, \"loaded\", {\n        enumerable: true,\n        get: function get() {\n          return module.l;\n        }\n      });\n      Object.defineProperty(module, \"id\", {\n        enumerable: true,\n        get: function get() {\n          return module.i;\n        }\n      });\n      module.webpackPolyfill = 1;\n    }\n    return module;\n  };\n\n  /***/\n}, /* 15 */\n/***/function (module, exports) {\n  var g;\n\n  // This works in non-strict mode\n  g = function () {\n    return this;\n  }();\n  try {\n    // This works if eval is allowed (see CSP)\n    g = g || new Function(\"return this\")();\n  } catch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\") g = window;\n  }\n\n  // g can still be undefined, but nothing to do about it...\n  // We return undefined, instead of nothing here, so it's\n  // easier to handle this case. if(!global) { ...}\n\n  module.exports = g;\n\n  /***/\n}, /* 16 */\n/***/function (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  module.exports = {\n    isString: function isString(arg) {\n      return typeof arg === 'string';\n    },\n    isObject: function isObject(arg) {\n      return typeof arg === 'object' && arg !== null;\n    },\n    isNull: function isNull(arg) {\n      return arg === null;\n    },\n    isNullOrUndefined: function isNullOrUndefined(arg) {\n      return arg == null;\n    }\n  };\n\n  /***/\n}, /* 17 */\n/***/function (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  exports.decode = exports.parse = __webpack_require__(18);\n  exports.encode = exports.stringify = __webpack_require__(19);\n\n  /***/\n}, /* 18 */\n/***/function (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n  // If obj.hasOwnProperty has been overridden, then calling\n  // obj.hasOwnProperty(prop) will break.\n  // See: https://github.com/joyent/node/issues/1707\n  function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n  module.exports = function (qs, sep, eq, options) {\n    sep = sep || '&';\n    eq = eq || '=';\n    var obj = {};\n    if (typeof qs !== 'string' || qs.length === 0) {\n      return obj;\n    }\n    var regexp = /\\+/g;\n    qs = qs.split(sep);\n    var maxKeys = 1000;\n    if (options && typeof options.maxKeys === 'number') {\n      maxKeys = options.maxKeys;\n    }\n    var len = qs.length;\n    // maxKeys <= 0 means that we should not limit keys count\n    if (maxKeys > 0 && len > maxKeys) {\n      len = maxKeys;\n    }\n    for (var i = 0; i < len; ++i) {\n      var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr,\n        vstr,\n        k,\n        v;\n      if (idx >= 0) {\n        kstr = x.substr(0, idx);\n        vstr = x.substr(idx + 1);\n      } else {\n        kstr = x;\n        vstr = '';\n      }\n      k = decodeURIComponent(kstr);\n      v = decodeURIComponent(vstr);\n      if (!hasOwnProperty(obj, k)) {\n        obj[k] = v;\n      } else if (isArray(obj[k])) {\n        obj[k].push(v);\n      } else {\n        obj[k] = [obj[k], v];\n      }\n    }\n    return obj;\n  };\n  var isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n\n  /***/\n}, /* 19 */\n/***/function (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  var stringifyPrimitive = function stringifyPrimitive(v) {\n    switch (typeof v) {\n      case 'string':\n        return v;\n      case 'boolean':\n        return v ? 'true' : 'false';\n      case 'number':\n        return isFinite(v) ? v : '';\n      default:\n        return '';\n    }\n  };\n  module.exports = function (obj, sep, eq, name) {\n    sep = sep || '&';\n    eq = eq || '=';\n    if (obj === null) {\n      obj = undefined;\n    }\n    if (typeof obj === 'object') {\n      return map(objectKeys(obj), function (k) {\n        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n        if (isArray(obj[k])) {\n          return map(obj[k], function (v) {\n            return ks + encodeURIComponent(stringifyPrimitive(v));\n          }).join(sep);\n        } else {\n          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n        }\n      }).join(sep);\n    }\n    if (!name) return '';\n    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n  };\n  var isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n  function map(xs, f) {\n    if (xs.map) return xs.map(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n      res.push(f(xs[i], i));\n    }\n    return res;\n  }\n  var objectKeys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n  };\n\n  /***/\n}, /* 20 */\n/***/function (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  // ESM COMPAT FLAG\n  __webpack_require__.r(__webpack_exports__);\n\n  // EXPORTS\n  __webpack_require__.d(__webpack_exports__, \"randomId\", function () {\n    return (/* reexport */randomId_randomId\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"URLWithHashParams\", function () {\n    return (/* reexport */url_URLWithHashParams\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"base64url\", function () {\n    return (/* reexport */base64url\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"safebtoa\", function () {\n    return (/* reexport */safebtoa\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"safeatob\", function () {\n    return (/* reexport */safeatob\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"keccak\", function () {\n    return (/* reexport */keccak\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"base64toJSON\", function () {\n    return (/* reexport */base64toJSON\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"jsonToBase64\", function () {\n    return (/* reexport */jsonToBase64\n    );\n  });\n  __webpack_require__.d(__webpack_exports__, \"keccak256\", function () {\n    return (/* reexport */keccak256\n    );\n  });\n\n  // EXTERNAL MODULE: external \"randombytes\"\n  var external_randombytes_ = __webpack_require__(1);\n  var external_randombytes_default = /*#__PURE__*/__webpack_require__.n(external_randombytes_);\n\n  // CONCATENATED MODULE: ./src/randomId.ts\n  // TODO: should be crypto safe\n\n  var randomId_randomId = function randomId() {\n    return external_randombytes_default()(32).toString(\"hex\");\n  };\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/classCallCheck\"\n  var classCallCheck_ = __webpack_require__(2);\n  var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck_);\n\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/createClass\"\n  var createClass_ = __webpack_require__(3);\n  var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass_);\n\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/assertThisInitialized\"\n  var assertThisInitialized_ = __webpack_require__(4);\n  var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized_);\n\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/get\"\n  var get_ = __webpack_require__(5);\n  var get_default = /*#__PURE__*/__webpack_require__.n(get_);\n\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/inherits\"\n  var inherits_ = __webpack_require__(6);\n  var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits_);\n\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/possibleConstructorReturn\"\n  var possibleConstructorReturn_ = __webpack_require__(7);\n  var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn_);\n\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/getPrototypeOf\"\n  var getPrototypeOf_ = __webpack_require__(0);\n  var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf_);\n\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/wrapNativeSuper\"\n  var wrapNativeSuper_ = __webpack_require__(8);\n  var wrapNativeSuper_default = /*#__PURE__*/__webpack_require__.n(wrapNativeSuper_);\n\n  // EXTERNAL MODULE: external \"@babel/runtime/helpers/defineProperty\"\n  var defineProperty_ = __webpack_require__(9);\n  var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);\n\n  // EXTERNAL MODULE: /home/chai/source/repos/torus/OpenLoginSdk/node_modules/url/url.js\n  var url = __webpack_require__(10);\n\n  // CONCATENATED MODULE: ./src/url.ts\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n      var Super = getPrototypeOf_default()(Derived),\n        result;\n      if (hasNativeReflectConstruct) {\n        var NewTarget = getPrototypeOf_default()(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return possibleConstructorReturn_default()(this, result);\n    };\n  }\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  var url_URLWithHashParams = /*#__PURE__*/function (_URL) {\n    inherits_default()(URLWithHashParams, _URL);\n    var _super = _createSuper(URLWithHashParams);\n    function URLWithHashParams() {\n      var _this;\n      classCallCheck_default()(this, URLWithHashParams);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _super.call.apply(_super, [this].concat(args));\n      defineProperty_default()(assertThisInitialized_default()(_this), \"hashParams\", new url[\"URLSearchParams\"]());\n      return _this;\n    }\n    createClass_default()(URLWithHashParams, [{\n      key: \"toString\",\n      value: function toString() {\n        this.hash = this.hashParams.toString();\n        return get_default()(getPrototypeOf_default()(URLWithHashParams.prototype), \"toString\", this).call(this);\n      }\n    }]);\n    return URLWithHashParams;\n  }( /*#__PURE__*/wrapNativeSuper_default()(URL));\n  // EXTERNAL MODULE: external \"base64url\"\n  var external_base64url_ = __webpack_require__(11);\n  var external_base64url_default = /*#__PURE__*/__webpack_require__.n(external_base64url_);\n\n  // EXTERNAL MODULE: external \"keccak\"\n  var external_keccak_ = __webpack_require__(12);\n  var external_keccak_default = /*#__PURE__*/__webpack_require__.n(external_keccak_);\n\n  // CONCATENATED MODULE: ./src/utils.ts\n\n  var base64url = external_base64url_default.a;\n  function safebtoa(str) {\n    return base64url.encode(str);\n  }\n  function safeatob(str) {\n    // Going backwards: from bytestream, to percent-encoding, to original string.\n    return base64url.decode(str);\n  }\n  var keccak = external_keccak_default.a;\n  function base64toJSON(b64str) {\n    return JSON.parse(base64url.decode(b64str));\n  }\n  function jsonToBase64(json) {\n    return base64url.encode(JSON.stringify(json));\n  }\n  function keccak256(str) {\n    var input = str;\n    if (typeof str === \"string\" && str.slice(0, 2) === \"0x\" && str.length === 66) {\n      input = Buffer.from(str.slice(2), \"hex\");\n    }\n    var data = \"0x\".concat(keccak(\"keccak256\").update(input).digest(\"hex\").padStart(64, \"0\"));\n    return data;\n  } // TODO: not all of the options are implemented\n  // CONCATENATED MODULE: ./index.ts\n\n  /***/\n}\n/******/]);","map":null,"metadata":{},"sourceType":"script"}